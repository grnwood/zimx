## Task 1 - Schema
You are working in a FastAPI-based server that reads and writes page files on disk.
Clients NEVER touch the filesystem directly; they only use the API.

Goal: Add a full-text search feature backed by SQLite FTS (FTS5) instead of grepping files.
The server should:

- Keep the filesystem as the source of truth for page content.
- Maintain a small SQLite "sidecar" DB that mirrors pages for search.
- Provide a `GET /search?q=...` endpoint that searches full text across all pages and returns ranked results with snippets.

--------------------------------
CONTEXT / ASSUMPTIONS
--------------------------------

- Each "page" is stored as a text file on disk (e.g., Markdown).
- The FastAPI app already has endpoints to:
  - Create / update a page (e.g. PUT /pages/{path})
  - Delete a page (e.g. DELETE /pages/{path})
  - Read a page (GET /pages/{path})
- There is already some SQLite usage in the app, OR we can add a dedicated SQLite file for search, e.g. `search_index.db`.
- Use SQLite FTS5.

If the project already has a DB helper / dependency, reuse it. Otherwise, create a minimal one for this feature.

--------------------------------
TASK 1 – Create SQLite FTS schema
--------------------------------

Create (or extend) a SQLite database with two tables:

1) `pages`
   - Columns:
     - `id` INTEGER PRIMARY KEY
     - `path` TEXT NOT NULL UNIQUE   -- canonical file path or page identifier used by the API
     - `mtime` INTEGER NOT NULL      -- last modified time in epoch seconds

2) `pages_fts` (FTS5 virtual table)
   - Columns:
     - `content`   -- full text of the file
   - Use `content_rowid='id'` to link to `pages.id`.

SQL DDL (adjust names to match the project style):

```sql
CREATE TABLE IF NOT EXISTS pages (
    id      INTEGER PRIMARY KEY,
    path    TEXT NOT NULL UNIQUE,
    mtime   INTEGER NOT NULL
);

CREATE VIRTUAL TABLE IF NOT EXISTS pages_fts USING fts5(
    content,
    content_rowid='id'
);
````

Optional: add indexes on `pages.path` and `pages.mtime` if needed.

---

## TASK 2 – Add a search-index helper module

Create a Python module, e.g. `search_index.py`, that exposes functions:

* `init_search_db()` – ensure tables exist.
* `upsert_page(path: str, mtime: int, content: str) -> None`
* `delete_page(path: str) -> None`
* `search_pages(query: str, limit: int = 50) -> list[dict]`

Implementation details:

`upsert_page`:

* In a transaction:

  * Insert or update `pages` row by `path`:

    * If path exists, update `mtime`.
    * Else insert.
  * Get `id` for that path.
  * Insert or update `pages_fts` row:

    * `INSERT INTO pages_fts(rowid, content) VALUES (?, ?)`
    * If rowid already exists, use `INSERT OR REPLACE` or a separate `UPDATE`.

`delete_page`:

* Lookup `id` by `path` from `pages`.
* Delete row from `pages` and `pages_fts` with that `id`.

`search_pages`:

* Use `MATCH` query over `pages_fts`.
* Join back to `pages` to get `path`.
* Use SQLite snippet/bm25 if available.

Example SQL:

```sql
SELECT
  p.path,
  snippet(pages_fts, 0, '[', ']', '...', 10) AS snippet,
  bm25(pages_fts) AS rank
FROM pages_fts
JOIN pages p ON p.id = pages_fts.rowid
WHERE pages_fts MATCH ?
ORDER BY rank
LIMIT ?;
```

Return Python dictionaries like:

```python
{
  "path": "Project/ZimX/Design.md",
  "snippet": "...some [highlighted] content...",
}
```

`search_index.py` should contain all DB-specific logic. FastAPI layer should only call these functions.

---

## TASK 3 – Hook search index into write/delete flows

Find the FastAPI handlers where pages are created/updated/deleted.

For example (pseudo):

* `PUT /pages/{path}` handler:

  * Validates data.
  * Writes the file to disk (path → file).
  * Determine `mtime` (e.g. `int(time.time())` or `os.path.getmtime(filepath)`).
  * Call `search_index.upsert_page(path, mtime, content)`.

* `DELETE /pages/{path}` handler:

  * Deletes the file on disk.
  * Calls `search_index.delete_page(path)`.

Important: server remains the only code that writes to disk, so the DB stays in sync automatically. No filesystem watcher is required.

---

## TASK 4 – Implement `/search` API endpoint

Add a FastAPI route:

```python
GET /search?q=...&limit=...
```

Behavior:

* Validate that `q` is non-empty.
* Call `search_index.search_pages(q, limit)`.
* Return JSON response with an array of objects:

```json
[
  {
    "path": "Project/ZimX/Design.md",
    "snippet": "...text with [q] in context..."
  },
  ...
]
```

This endpoint should NOT directly read files from disk.
If later we want to fetch the full page, clients should use the existing `/pages/{path}` endpoint.

---

## TASK 5 – Wiring & basic error handling

* Ensure `init_search_db()` is called once at app startup (e.g. FastAPI startup event).
* Handle errors gracefully:

  * If `search_pages` fails, return a 500 with a simple error message.
* Log search queries and any DB exceptions for debugging.

---

## TASK 6 – (Optional) CMD/REPL sanity test

Add a small test utility (or script) that:

* Inserts a couple of sample pages via `upsert_page`.
* Searches for a query.
* Prints results to stdout.

This helps verify FTS wiring without needing the full FastAPI stack running.

---

## CONSTRAINTS / STYLE

* Use SQLite’s built-in `sqlite3` module unless the project already uses SQLAlchemy or another ORM; if it does, follow the existing pattern.
* Keep the FTS integration minimal and straightforward.
* Do NOT implement incremental re-indexing from disk; indexing is triggered only by API writes/deletes.
* Do NOT use grep or external processes; all search is via SQLite FTS.

```

---

You can paste that whole block as a comment or as a prompt to your local coding assistant (Codex / Copilot-like) and let it generate the schema + helper module + FastAPI route in your actual project structure.

If you want, I can also write a **second brief** focused just on “Refactor `search_index.py` to use connection pooling / dependency injection,” once you get the basic version in.
```	
